//
//  JMWebResourceInterceptorURLProtocol.m
//  JoyMapsKit
//
//  Created by laijiandong on 12/24/14.
//  Copyright (c) 2014 laijiandong. All rights reserved.
//

//#import "JMCore.h"

#import "JMWebResourceURLProtocol.h"
#import "JMWebResourceInterceptor.h"
#import "JMWebResourceCache.h"
#import "md5.h"
#import "MD5EX.h"
#import "AppBridgeUtil.h"

#define JM_WEB_REQUEST_TRACKING_KEY     @"jm_req_tracking"
#define JM_WEB_REQUEST_TRACKING_START_KEY     @"jm_req_tracking_start"
#define JM_WEB_REQUEST_TRACKING_END_KEY     @"jm_req_tracking_end"

@interface JMWebResourceURLProtocol () <NSURLConnectionDelegate>

// the key associated cached content, generated by url and path extension
@property (nonatomic, strong) NSString *cacheKey;

// resource connection,
@property (nonatomic, strong) NSURLConnection *internalConnection;
@property (nonatomic, strong) NSURLResponse *internalResponse;

// the css and js both tiny text body, so save it in memory directly,
// flush it to disk when all content returns from server.
@property (nonatomic, strong) NSMutableData *responseData;

@property (nonatomic) NSTimeInterval startTime;
@property (nonatomic) NSTimeInterval endTime;
@property (nonatomic) BOOL retryFlag;

@end

@implementation JMWebResourceURLProtocol


//////////////////////////////////////////////////////////////////////////////////

#pragma mark -
#pragma mark private methods

+ (NSString *)pathExtensionFromComboURL:(NSURL *)url {
    NSString *extension = nil;
    
    // the combo url format like: http://tb.cn/g??a-v1.js,b-v2.js,c-v3.js
    NSString *query = [url query];
    if (query != nil && [query hasPrefix:@"?"]) {
        NSArray *components = [query componentsSeparatedByString:@","];
        if (components != nil && [components count] > 0) {
            // all the resources in combo url must same type,
            // so return the extension of first item
            extension = [components[0] pathExtension];
        }
    }
    
    return extension;
}

// check the request is used to get combo content from server
+ (BOOL)isSupportedComboURLRequest:(NSURLRequest *)request {
    NSString *extension = [JMWebResourceURLProtocol pathExtensionFromComboURL:request.URL];
    BOOL supported = [[JMWebResourceInterceptor globalWebResourceInterceptor] isSupportedPathExtension:extension];
    
    return supported;
}

//
+ (NSString *)getHostInRequest:(NSURLRequest *)request path:(NSString **)path {
    NSDictionary *fields = [request allHTTPHeaderFields];
    
    NSString *host = request.URL.host;
    
    //启用Request Host
    if (host == nil) {
        // search 'Referer' field at firstly
        NSString *referer = fields[@"Referer"];
        if (referer != nil && [referer length] > 0) {
            NSURL *url = [NSURL URLWithString:referer];
            host = [url host];
            
            if (path != NULL) {
                *path = [url path];
            }
            
        } else {
            host = fields[@"Host"];
        }
    }
    
    if (host != nil && [host hasPrefix:@"www."]) {
        // remove "www." from host
        host = ([host length] > 4) ? [host substringFromIndex:4] : nil;
    }
    
    return host;
}

// generate the cache content filename base on current request url
- (NSString *)cacheContentNameFromURL:(NSURL *)url {
    // the fully url as unique key
    NSString *prefix = [MD5EX md5_string:[url absoluteString]];
    
    // save the path extension to generate file MIME type at later
    NSString *extension = [[[url lastPathComponent] pathExtension] lowercaseString];
    if (extension == nil || [extension length] == 0) {
        // get the extension from combo url
        extension = [JMWebResourceURLProtocol pathExtensionFromComboURL:url];
    }
    
    NSString *filename = [prefix stringByAppendingFormat:@".%@", extension ? : @""];
    
    return filename;
}

// build response with specified data
- (NSHTTPURLResponse *)buildResponseWithData:(NSString *)data {
    return nil;
}


+ (void) applyCustomHeaders:(NSMutableURLRequest*) request {
    if ([JULocationManager sharedInstance].isLatestLocateSuccess) {
        NSString *lng = [NSString stringWithFormat:@"%f",[JULocationManager sharedInstance].latestLocation.coordinate.longitude] ;
        NSString *lat = [NSString stringWithFormat:@"%f",[JULocationManager sharedInstance].latestLocation.coordinate.latitude] ;
        
        [request addValue:lat forHTTPHeaderField:@"lat"];
        [request addValue:lng forHTTPHeaderField:@"lng"];
    }
    
    if ([TBTop sharedInstance].token != nil) {
        [request addValue:[TBTop sharedInstance].token forHTTPHeaderField:@"token"];
    }
    
    if ([TBTop getUniqueIdentifierForVendor] != nil) {
        [request addValue:[TBTop getUniqueIdentifierForVendor] forHTTPHeaderField:@"udid"];
    }

}

- (NSURLResponse *)constructDataResponse:(NSData *)resultBridgeData requestURL:(NSURL *)requestURL {
    NSURLResponse *customResponse = nil;
    NSMutableDictionary *customFields = [NSMutableDictionary dictionaryWithCapacity:2];
    
    customFields[@"Content-Type"] = @"application/json;charset=utf-8";
    
    // content length
    customFields[@"Content-Length"] = [NSString stringWithFormat:@"%ld", (unsigned long)[resultBridgeData length]];
    customResponse = [[NSHTTPURLResponse alloc] initWithURL:requestURL
                                                 statusCode:200
                                                HTTPVersion:@"HTTP/1.1"
                                               headerFields:customFields];
    return customResponse;
}


//////////////////////////////////////////////////////////////////////////////////

#pragma mark -
#pragma mark public methods

+ (BOOL)canRequestMatchCacheRules:(NSURLRequest *)request{
    JMWebResourceInterceptor *interceptor
    = [JMWebResourceInterceptor globalWebResourceInterceptor];
    
    // step 1, check web resource interceptor is opening
    if (!interceptor.settings.enabled) return NO; // not support web resource interceptor
    
    // step 4, check the path extension of request was supported or not
    NSString *extension = [[[request.URL lastPathComponent] pathExtension] lowercaseString];
    if (extension == nil || [extension length] == 0) {
        // check it was supported combo url when path extension is nil
        if (![JMWebResourceURLProtocol isSupportedComboURLRequest:request]) return NO; // not support
        
    } else {
        if (request.URL.query != nil && [request.URL.query rangeOfString:@"native_cache="].location != NSNotFound) {
            //有默认开启Native缓存的链接，权限最高
            return YES;
        }
        if (![interceptor isSupportedPathExtension:extension]) return NO; // not support
    }
    
    // setp 5, check the reference host is in black/white host
    NSString *path = nil;
    NSString *host = [JMWebResourceURLProtocol getHostInRequest:request path:&path];
    if (host != nil) {
        if (path != nil) {
            NSString *urlPath = [host stringByAppendingPathComponent:path];
            // check host is in blacklist
            if ([interceptor isBlacklistWithRequestPath:urlPath]) {
                return NO;
            }
        }
        
        // check host is in whitelist
        if ([interceptor isCacheWhitelistHost:host]) {
            return YES; // can handle the request use custom protocol
        }
    }
    
    return NO;
}

// override
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
//    NSLog(@"JMWebResourceURLProtocol track url %@",request.URL);
    
    
    // step 2, check the request did marked
    id prop = [NSURLProtocol propertyForKey:JM_WEB_REQUEST_TRACKING_KEY inRequest:request];
    if (prop != nil) {
        return NO; // aviod loading cycle
    }
    
    // step 3, check the scheme of request
    NSString *scheme = [request.URL scheme];
    if (scheme == nil) return NO; // the request schema can not be nil
    
    scheme = [scheme lowercaseString];
    if (!([scheme isEqualToString:@"http"]
          || [scheme isEqualToString:@"https"])) {
        return NO; // for now, the scheme should be 'http' or 'https'
    }
    
    return YES;
}

// override
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}



// override
- (void)startLoading {
    NSURL *requestURL = self.request.URL;
    
    NSData *cacheData = nil;
    NSURLResponse *customResponse = nil;
    
    //拦截同步请求
    if ([AppBridgeUtil isSyncBridgeRequest:requestURL]) {
        NSData* resultBridgeData = [AppBridgeUtil performSyncBridgeRequest:requestURL];
        
        customResponse = [self constructDataResponse:resultBridgeData requestURL:requestURL];
        
        [self.client URLProtocol:self
              didReceiveResponse:customResponse
              cacheStoragePolicy:NSURLCacheStorageAllowedInMemoryOnly];
        
        // notify did finish load data
        [self.client URLProtocol:self didLoadData:resultBridgeData];
        
        // notify did finish loading
        [self.client URLProtocolDidFinishLoading:self];

    }
    
    JMWebResourceInterceptor *interceptor
    = [JMWebResourceInterceptor globalWebResourceInterceptor];
    
    // get data from cache
    if ([JMWebResourceURLProtocol canRequestMatchCacheRules:self.request]) {
        // generate key for local cache content
        self.cacheKey = [self cacheContentNameFromURL:requestURL];

        if ([interceptor.cache hasCacheForKey:_cacheKey]) { // check cache data is available
            // load cache data with associated key
            cacheData = [interceptor.cache cacheDataForKey:_cacheKey
                                                       url:requestURL
                                                  response:&customResponse];
            
            if (cacheData == nil) {
                // the cache index did expired, remove it form cache index table
                [interceptor.cache removeCacheIndexForKey:_cacheKey];
            }
        }
    } else {
        //没有在缓存列表中，可能网络白名单之外
        NSString *path = nil;
        NSString *host = [JMWebResourceURLProtocol getHostInRequest:self.request path:&path];
        if (host != nil) {
            
            // check host is in whitelist
            if (![interceptor isGlobalNetworkOutWhitelistHost:host]) {
//                NSData* nullData = [@"out of whitelist" dataUsingEncoding:NSUTF8StringEncoding];
                
//                //直接返回空数据，以下两个函数执行会崩溃
                customResponse = [self constructDataResponse:[@"false" dataUsingEncoding:NSUTF8StringEncoding] requestURL:requestURL];
                
                [self.client URLProtocol:self
                      didReceiveResponse:customResponse
                      cacheStoragePolicy:NSURLCacheStorageAllowedInMemoryOnly];
                
                // notify did finish load data
                [self.client URLProtocol:self didLoadData:cacheData];
                
                [self.client URLProtocolDidFinishLoading:self];
                return;
            }
        }
    }
    
    if (cacheData != nil) {
//      NSLog(@"resource cache hint->%@",requestURL);
//      notify did receive response
        [self.client URLProtocol:self
                       didReceiveResponse:customResponse
                         cacheStoragePolicy:NSURLCacheStorageAllowedInMemoryOnly];
        
        // notify did finish load data
        [self.client URLProtocol:self didLoadData:cacheData];
        
        // notify did finish loading
        [self.client URLProtocolDidFinishLoading:self];
        
    } else {

        NSMutableURLRequest *request = [self.request mutableCopy];
        [request setCachePolicy:NSURLRequestReloadIgnoringCacheData];
        
        [request setTimeoutInterval:15.0]; //设置超时
        
        [JMWebResourceURLProtocol applyCustomHeaders:request];
        [NSURLProtocol setProperty:@(YES) forKey:JM_WEB_REQUEST_TRACKING_KEY inRequest:request];
        self.startTime = [[NSDate date] timeIntervalSince1970]*1000;
        self.internalConnection = [NSURLConnection connectionWithRequest:request delegate:self];
        
    }
}

// override
- (void)stopLoading {
    [self.internalConnection cancel];
    
    self.responseData = nil;
}


//////////////////////////////////////////////////////////////////////////////////

#pragma mark -
#pragma mark NSURLConenction delegate methods

- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response {
    [self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed];
    
    self.internalResponse = response;
    self.responseData = [[NSMutableData alloc] init];
}

- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data {
    [self.client URLProtocol:self didLoadData:data];
    
    [self.responseData appendData:data];
}

- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error {
    self.endTime = [[NSDate date] timeIntervalSince1970]*1000;
    
    if (!self.retryFlag) {
        self.retryFlag = YES;
        [self startLoading];
    } else {
        [self.client URLProtocol:self didFailWithError:error];
    }
}


- (void)connectionDidFinishLoading:(NSURLConnection *)connection {
    self.endTime = [[NSDate date] timeIntervalSince1970]*1000;;
    
    [self.client URLProtocolDidFinishLoading:self];
    if ([self.internalResponse isKindOfClass:[NSHTTPURLResponse class]] && ((NSHTTPURLResponse*)self.internalResponse).statusCode == 200) {
        
        //MD5 校验 || http状态检查
        BOOL md5CheckPass = YES;//默认检查通过
        if ([self.internalResponse respondsToSelector:@selector(allHeaderFields)]) {
            NSString* md5FromServer = [[[(NSHTTPURLResponse*)self.internalResponse allHeaderFields] objectForKey:@"x-oss-meta-md5"] uppercaseString];
            if (md5FromServer != nil && ![md5FromServer isEqualToString:@""]) {
                //开始md5校验
                NSString* md5Data = [[MD5EX md5_data:self.responseData] uppercaseString];
                if ([md5FromServer isEqualToString:md5Data]) {
                    md5CheckPass = YES;
                } else {
                    md5CheckPass = NO;
                }
            }
        }
        
        // get data from cache
        if ([JMWebResourceURLProtocol canRequestMatchCacheRules:self.request] && md5CheckPass) {
            
            // store cache response data
            JMWebResourceInterceptor *interceptor
            = [JMWebResourceInterceptor globalWebResourceInterceptor];
            
            [interceptor.cache storeCacheData:_responseData
                                     response:_internalResponse
                                       forKey:_cacheKey
                              completionBlock:nil];

        }
        
    } else {

    }
}

- (NSURLRequest *)connection:(NSURLConnection *)connection willSendRequest:(NSURLRequest *)request redirectResponse:(NSURLResponse *)response
{
    if (response != nil)
    {
        [[self client] URLProtocol:self wasRedirectedToRequest:request redirectResponse:response];
    }
    return request;
}

- (BOOL)connectionShouldUseCredentialStorage:(NSURLConnection *)connection
{
    return YES;
}

- (void)connection:(NSURLConnection *)connection
    didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge
{
    [self.client URLProtocol:self
        didReceiveAuthenticationChallenge:challenge];
}

- (void)connection:(NSURLConnection *)connection
    didCancelAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge
{
    [self.client URLProtocol:self
        didCancelAuthenticationChallenge:challenge];
}

- (NSCachedURLResponse *)connection:(NSURLConnection *)connection
    willCacheResponse:(NSCachedURLResponse *)cachedResponse
{
    return cachedResponse;
}

@end
